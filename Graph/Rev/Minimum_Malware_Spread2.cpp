class Solution {
public:
int Get(vector<int> &parent,int a){
    return parent[a]=((parent[a]==a)?a:Get(parent,parent[a]));
}
void Union(vector<int> &parent,vector<int> &rank,int a,int b){
     int lx=Get(parent,a);
    int ly=Get(parent,b);
    
    if(lx!=ly){
        
        if(rank[lx]>rank[ly]){
            rank[lx]+=rank[ly];
            parent[ly]=lx;
        }
        
        else{
            rank[ly]+=rank[lx];
            parent[lx]=ly;
        }
        
    }
}

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
	int n=graph.size();
	int m=graph[0].size();
	std::set<int> init;
vector<int> parent(305);
vector<int> rank(305);
for(int i=0;i<n;i++){
	parent[i]=i;
	rank[i]=1;
}
	for(int i=0;i<initial.size();i++){
		init.insert(initial[i]);
	}
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			if(graph[i][j]==1 && (not init.count(i)) && (not init.count(j))){
				Union(parent,rank,i,j);
			}
		}
	}
	std::map<int,std::set<int>> mp;
	std::vector<int> infected(n,0);
	//in mp we will store those nodes which will effected by initial element
	for(int i:initial){
		for(int j=0;j<m;j++){
			if(graph[i][j]==1 && i!=j && (not init.count(j))){
			int par=Get(parent,j);
			if(not mp[i].count(par)){
				mp[i].insert(par);
				infected[par]++;
			}
		}
	}
}
int ans=-1;
int mx_sz=-1;
for(int u:initial){
	std::set<int> nbr=mp[u];
	int total=0;
	for(int par:nbr){
		if(infected[par]==1){
			total+=rank[par];
		}
	}
	if(total>=mx_sz){
		if(total==mx_sz){
			ans=std::min(ans,u);
		}
		else{
			ans=u;
		}
		mx_sz=total;
	}
}
    cout<<ans<<" ";
if(ans==-1){
	std:sort(initial.begin(),initial.end());
	ans=initial[0];
}
    for(int i=0;i<n;i++){
        std::cout<<rank[i]<<"  ";
    }
    
return ans;
}
};